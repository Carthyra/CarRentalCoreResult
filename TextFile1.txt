** projedeki hiç bir classın boş kalmaması önemli. boşta olsa bir interface implemente etmemiz gerekiyor.
** abstract nesneleri ile classlarımı işaretliyoruz.

Abstrat klasörlerine içerisinde soyut nesneler yer alıyor. nedir bu soyut nesneler 
(interfaceler) 
(abstract nesneler) => bu neseneler nedir bunlara bakalım.
(base classlar) => base classlar, core classlar.
Abstractların içerisine referans tutucuları koyuyoruz.

Concrete klasörlerine ise somut nesneleri kullanıyoruz. gerçek işi yapan classları buraya koyuyoruz.

**Entities** kısmı veri tabanındaki tablolar.:
Concrete Klasöründe: veri tabanlarına ilişkin alanlar yer alıyor. dtolar ve joinli yapılarda burada yer alıyor.
propertyleri tutarlar. içerisindeki classlar public olmalıdır. classın public olması, classa diğer katmanların erişebilmesini 
sağlar.
Abstract Klasörü: buraya IEntity diye bir interface oluşturduk. içi boş. IEntity implemente eden class bir veri tabanı tablosudur.



DataAccess kısmında ise entities de yer alan tabloların erişimleri vardır. burada erişim metodları arasında 
entitiy framework, inmemory gibi durumlar söz konusu. 
Abstract Klasöründe: nesnelerin başına hangi veri erişim metodu sonunada "Dal" ifadesi kullanılan interfaceler oluşturulur.
IProductDal => product ın dataaccess layer ına ilişkin interface.
IProductDal içerisinde CRUD metodlarının imzalarını tanımladık. (Product için ileride bunu ortak yapabiliriz.)
ICategoryDal => category classının dataaccess layerına ilişkin interface.
ICategoryDal içerisinde CRUD metodlarının imzalarını tanımladık. (Category için ileride bunu ortak yapabiliriz.)
ICategoryDal ve IProductDal içerisinde yer alan metodlar neredeyse aynı bunun için bir generic oluştursak.
ve by generiğe Category verince ICategoryDal, Product verince IPorductDal gibi çalışsa.
bu yapıya Generic Reporsitory Design Patern => bunu araştıralım.
Generic olarak IEntityRepository'i oluşturduk. (interface)
IEntityRepository içerisine IProductDal da yer alan imza metodları aldık.
IEntityRepository deki metodlar bütün veri tabanı nesnelerinde kullanılacağından GetAllByCategory kısmını 
revize etmemiz lazım. bunun için yapacağımız şey:
GetAll() metodu ile hepsini alabiliyoruz. içerisine (Expression<Func<T,bool>> filter=null) dediğimizde:
GetAll(Expression<Func<T,bool>> filter=null) bu ifade ile filtre vermediğimizde bütün data gelirken
filtre olarak bir değer verirsek bu durumda filtrelenmiş data gelecek.
Bu sayede GetAllByCategory() metodlara ihtiyacımız kalmayacak.
Ayrıca bu alanda bir liste değilde sadece tek bir eleman getirmek istiyoruz. bunun için:
T Get(); diye bir metod tanımlıyoruz. bu metodun başında List<T> olmaması gelecek olan verinin 
tek olduğu liste olmadığını gösterir.
Bu metodda ise GetAll() da verdiğimiz Expressionı veriyoruz ancak. filtre=null kısmı olmayacak.
Bunun nedeni ise burası tek bir değer döneceğinden dolayı filtreleme zorunlu olmalı.
Şimdi IEntityReposity içerisinde metodlarımızın imzalarını tanımladık. Next?
ICategoryDal ve IProdcutDal içerisindeki imza metodları siliyoruz onlara gerek kalmadı.
Daha sonra ICategoryDal : IEntityRepository<Category> , IProductDal : IEntityRepository<Product> diyerek inherite ediyoruz.
??? peki bu <Category> yada <Product> kısımlarını newlerken veremezmiyiz???
??? bu sayede proje içerisinde iki .cs dosyasından kurtulmuş olmazmıyım???
Bunları yaptıktan sonra InMemoryProductDal için IProductDal ı yeniden implemete ediyoruz. bunun nedeni hata vermesini 
engellemek. Bundan sonra EntityFramework'ten çalışacağımız için burası önemli değil.

DataAccess Concrete EntityFramework:
Şimdi InMemoryKullanmayacağımızdan dolayı, EntityFramework klasörü içerisinde Abstract ta tanımladığımız interfacelerin
somut classlarını oluşturuyoruz.
EfCustomerDal => ICustomerDal dan inherite oluyor.
EfProductDal => IProductDal dan inherite oluyor.
EfCategoryDal => IProductDal dan inherite oluyor.
??? Bu üç IProductDal, ICustomerDal, ICategoryDal değilde IEntityRepository'den inheritance alamazmıyız ???
??? sanki yapabiliriz gibime geliyor ???
IEntiryRepository<T> generic oluşturmuştuk. burada T'nin alabilceği değerleri sınırlandırabiliriz.
Buna Generic Constraint deniliyor. Generic Kısıt demek.
Bu kısıtlamaları yapma amacım ise Entities içerisindeki Concrete klasöründe yer alan sınıfların yazılabilmesini
sağlamak. bu sınıflar dışında bir şey yazılırsa hata vermesini sağlamak.
IEntityRepository<T> where : class, IEntity, new()
where: kısmına T'nin alabileceği kısıtları koyuyoruz.
class: referans tutabilen şeyler yazılabilir T için (int, void, string vb. yazılmasını engelliyor.)
IEntity: IEntity interface'i yada bu interfacein implemente ettiği classların yazılması kısıtı.
(class diyince entities.concrete içerisindeki classların dışında classlarında yazılmasındas bir sıkıntı yoktu.)
(ama IEntity'i kısıt olarak verince bunu aşmış olduk.)
*** Fakat burada yine bir sıkıntımız var T için IEntity'nin kendiside verilebiliyor. bunu engellemek için ise
*** interfacelerin new() lemememesini kullanılıyorz.
new(): IEntity'nin T için değer olarak verilememesini engellemek için yaptığımız bir şey. interfaceler new() lenemez.
dolayısıyla IEntity'de new() lenemez.

Microsoft.EntityFramework.Core.Sql => burada console UI hangi dotnet sürümündeyse o sürüme göre yüklenmesi gerekiyor.
NuGet paketlerinden yükleniyor. DataAccess için yüklenicek. Çünkü EntityFramework için bağlantımızı burada yapacağız.
Şimdi veri tabanı ile entities.concrete içerisindeki classlar ile ilişkilendirmemiz lazım.
Bunun için DataAccess Abstract içerisine Context clasını kuruyoruz.
DataAccess.EntityFramework:
içerisinde NorthwindContext isimli class ı oluşturduk. DB tabloları ile proje tablolarını bağlayacağız.
override OnConfiguring => tab
içerisine => optionsBuilder.UseSqlServer(@"connection string")
*** bu yukarıdaki ikisi ile veritabanına bağlanmamızı sağlıyor.
*** daha sonra bunun altına hangi veri tabanı tablosu hangi proje classı ile ilişkili olacak onu belirtiyoruz.
*** Buna mappind deniyor sanırım. bunun custom mapping olayıda var.
*** bu ilişkileri prop ile veriyoruz.
public DbSet<projeclassı> Db_deki_balo {get,set} (prop ile yaptık. key DbSet içerisine proje içindeki class geliyor.)
Bağlatımızı yaptığımıza göre EfProductDal, EfCategoryDal, EfCustomerDal içindeki kodlarımızı düzenleyebiliriz.
CRUD operasyonlarımızı yazacağız. Daha sonra bu CRUD operasyonlarımızı injection ve ctor ile manager classlarımıza
aktarcağız.
***************************
EfProductDal, EfCategoryDal, EfCustomerDal, bunlar içerisindeki metodlarda northwindContex'imizi newlememiz lazım.
Ancak bu contex'in kullanımı ve new() lenerek heapte kalması bellek için maliyetli. kullanıp bellekten silmemiz lazım.
Bunun için IDisposible pattern diye bir şey kullanıyoruz.
using (NorthwindContext context = new NorthwindContext())
{
	CRUD metoduna ait kod => contex ile ekleme işlemleri farklı. bunların tutoriallarına bak!!!
}
Using içerisinde nortwindcontext'i newlememiz using içerisinde kod çalışıp işi bitince newlenen nortwindcontext i bellekten
siliyor. (garbage collector vasıtası ile.)

***********
northwind contex ile Crud metodlarında kod tekratı yapıyoruz bunu bir baseclassa alarak bundan kurtulabiliriz.
Bunu ilerleyen derslerde yapacağız.
*********
bu yukarıdaki crudları yazdıktan sonra Business classlarımıza bir bakmamız gerekiyor. hata varmı?
güncelleme gerekiyor mı gibisinden.




DataAccess'te CRUD operasyonlarını tanımlıyoruz.
** interface'in içerdiği metodlar default publictir. ancak interfacein kendisi değildir.
Concrete Klasörü: burada soyut nesnesi olacak. burada veri erişim yöntemleri yer alacak. inmemory, ado.net, depper,
entityframework. eğerki alternatif teknolojiler olan yerlerde kod yazıyorsak. klasörleme yapmamız gerekir. hangi teknoloji
içinse o kodlar o teknolojinin adı olan klasör oluşturulur.
Concrete içerisinde abstracta tanımladığımız interfacein iş yapan classlarını oluşturuyoruz. 
IProductDal => InMemoryProductDal gibi. hangi interface hangi class ile ilişkiliyse implemente işlemini yapıyoruz.
InMemoryProductDal da delete ve update metodları için neden silinemez sorusunun cevabı:
benim arayüzden gönderdiğim productın bilgilerinin aynısının olması önemli değil. burada heapte hangi adresi sileceğimizi
bildirmemiz gerekiyor. bunun içerisinde arayıp ürünü bulup o referans numarasının remove edilmesini belirtmemiz gerekmekte.
InMemoryProductDal:
burada interface içerisinde imza olarak belirtiğimiz metodların neler yapacaklarını kodladık.
Ayrıca burada inmemory olarak çalışacağımızda dolayı inmemory içerisine verilerimizin olduğu listeyi hazırlayıp belleğe göndermemiz
gerekmekte.
List<Car> _cars => global değişken => list of Car
bunun constructorını kurmamız lazım şu şekilde:
public InmemoryCarDal()
_cars = new List<Car> => _cars isimli global değişken list of Car
{
	new Car {} => arabalarımıza ait özelliklerimizi tanımladığımız listemizi oluşturuyoruz.
}



Business:
Abstract Klasörü: burada iş katmanında kullanacağımız servis operasyonlarını yazıyoruz.
burada sanki DataAccess'te ki işlerin aynısını yapıyor gibiyiz. bunun nedenini anlayalım.
Bunun nedeni iş kurallarının olmaması olabilir mi?
hayır aynı değil...
** DataAccess içerisinde Abstracta IProductDal ile tanımladığımız imza metodlarımızı yine DataAccess içerisinde 
** Concrete içerisinde InMemoryProductDal ile metodların ne iş yapacağını belirttik.
** Daha sonra Bussines içerisinde abstracta IProductService ile imza metodlarımızı tanıttık. yine Business içerisinde
** Concrete te ProductManager içerisinde IProdcutServici i implemente ettik.
** bu implemantasyonu yaparken IProductDal'ı class dışındas injection yaptık be bunun constructorını oluşturduk.
** bu sayede InMemoryProdcutDal'a impelemete edilen IProductDal'ı ve bu sayede InMemoryProductDal da tanımladığımız
** metodları IProductService içerisinde imza olarak belirtiğimiz metodların içerisine alabildik.
** Yani InMemoryProductDal da yazdığımız kodları yeniden yazmadık. Asla Kendini Tekrarlama ilkesine uyduk.

***********************************************************
9 uncu ders....
EfProductDal, EfCategoryDal, vb yerlerde kodların %90 ı aynı sadece List<> ile dönen tip ve verilen tipler değişiyor.
Bunun için bu alanlarda yer alan kodları idisposible paternleri ve verilen değerleri generic tip e çevirsem?
ve bu tipleri base bir class a çevirsem?
Bu nedenle yazılım geliştirme projelerinde framework katmanı oluştururuz.
buna core proje yapsak bu sayede başka projelerimizde de bu core katmanını oluştursak.
Core adında classlib oluşturduk.
Core katmanında hangi alt yapı ile ilgileceksen o lanları klasörlerini oluşturuyoruz.
DataAccess isminde bir klasör açtık. Veri erişimlerde kullanmak üzere. DataAccess e hizmet edecek Core kodları.
Core katmanındaki DataAccess içerisine => DataAccess içerisindeki IEntityRepository i taşıyorum.
Core katmanını proje içerinde bir yer ile refere etmiyoruz. bagımsız olmasını istiyoruz.
Bunu yapınca IEntity hata vericek. ancak IEntity bu proje özgü değil bu nedenle core a taşıyabiliriz.
Core katmanı diğer katmanları referans almaz.....
Başka katmanlar Core a bağımlı olabilir ancak Core başka bir katmana bağımlı olamaz.
Diğer katmanları COre a olan referanslarını hallet. (doslayarı taşıdığımız için.)
Code refactoring.

*** Core DataAccess EntityFramework klasörü oluşturduk.
Bu klasörün içerisine EfEntityFrameworkBase classını oluşturduk.
Bu yapının faydası veri tabanımıza yeni bir tablo eklediğimizde onun CRUD codlarını yazmayacağız.
Burada CRUD kodlarını bir kere yazıcaz ve her yerde onu kullanıcaz.
**** CORE içinde entityframework ü eklememiz lazım. NuGet'ten.
IEntityRepositoryBase e CRUD ları veriyoruz ancak <TEntity,TContext> olarak. 
IEntityRepository'i neden değiştirmedik hiç bu kısmı anlamadım.

***DTO = ilişkisel tablolarıdaki verileri gösterme...
DTO = Data Transformation Object  Entities İçerisinde bir klasör altında tanımlıyoruz.
ProductDetailDto : çıplak class kalmasın dedik ancak buraya IEntity yi inherite edemeyiz. IEntity veri tabanı nesnelerine
(tablolarına) verilerbilir. ancak dto'lar veri tabanı tabloları değil, veri tabanı tablolarının join i olabilir.
Bu yüzden IDto diye implemente etmemiz lazım.
IDto core da entities altında create ediliyor. DTO'lar implemente ediyor.
ProductDetailDto:
içerisine hangi alanları almak istiyorsak (farklı tablolardan) prop olarak veriyoruz.
BU dto'nun join kodunu ise IProductDal içersine imzasını yazıyoruz. sadece product ı ilgilendirdiği için
daha sonra IProductDal'ın inherite olduğu classlara implemente et (InMemoryProductDal, EfProductDal),
EfProductDal'ın içerisine DTO joini yazılır.
daha sonra bu metodun imzasını IProductService içine taşıyorumki. ProductManager içerisinde çağırabileyim.

****CORE UTİLİTİES****
CRUD operasyonlarının dönüşlerinin ve geri dönecek mesajlarının olduğu yer.
Utilities içerisine Results klasörü açtık içerindeki interfacelerde proplar yer alacak.
bu proplar sadece get; ile yazılıyor. Bu Result içerisinde abstract ve concrete klasörlerini yapabiliriz.
daha sonra bu interfacein somut sınıfını yapıyoruz.

*** AOP Giriş ***
Bussines içerisinde DependencyResolvers klasörü içerisinde Autofac klasörü (nuget paketi yükleniyor. 2 tane aop olanı)
Autofac ve Autofac.Extras.DynamiProxy paketlerini yüklüyoruz.
bunun içinde de AutofacBusinessModule classını yaptık.
Module ' ü inherite ettik classa (Autofac içerisinde olan Module'ü )
daha sonra override load ile builder yaptık.
builder içerisine:
builder.RegisterType<ProductManager>().As<IProductService>().SingleInstance();
** IProductService isteyen olursa ona ProductManager register et.
builder.RegisterType<EfProductDal>().As<IProductDal>().SingleInstance();
** IProductDal isteyen olursa EfProductDal register et.
bunları yerleştirdil. EfProductDal a ProductManager'ı newlerken ihtiyaç duyuyuroz.
SingleInstace ifadesi bir kere instanceını oluşturuyor ihtiyaç duyan yerlere onu veriyor.
Data tutmadığını bildiğimiz için singleinstace().
Bu yukarıdaki işlemleri daha önceden webapi içerisinde startup içerisinde yapmıştık.
Bunu backend de daha da geriye taşıyoruz. bunun nedeni ileride farklı bir api eklemek istersek
Bu yapıları oradan çekebilmek.
dolayısıyla webapi startup içerisinde ki aşağıdaki kodlara gerek kalmadı.
services.AddSingleton<IProductService,ProductManager>();
services.AddSingleton<IProductDal,EfProductDal>();


daha sonra bu Autofac i webapi içerisine aktarabilmemiz gerekiyor. bunun için ise
webapi içerisinde Program.cs içersinde 
.UseServiceProviderFactory(new AutofacServiceProviderFactory()) ==> burada autofac kullanacağımızı belirtiyoruz.
***AutofacServiceProviderFactory yazınca çözümleyebilmek için bir tane nuget paketi yüklememizi isteyecek.
*** yüklememiz gereken nuget paketi Autofac.Extension.DependencyInjection bu paketi yüklüyoruz.
.ConfigureContainer<ContainerBuilder>(builder => |==> burada ise autofac için hangi modülü (yazdığımız) bunu veriyoruz.
bunları ekliyoruz ve devamında builder için :
builder.RegisterModule(new AutofacBusinessModule()); ile autofac i veriyoruz.

daha sonra validasyon kurallarımız için:
Bussiness kodu ile doğrulama kodu ayrıdır. iş kuralları ile validasyon kodlarını ayrı yazmamız lazım.
Validasyon: nesnenin iş kurallarına dahil etmek için yapısal olarak doğru olup olmadığını kontrol ediyor.
örneğin: minimun iki karakter, şirede şu karakterler olmalı vb. yapısal uyum ile alakalı.
sayı aralığı ne olabilir vb.
iş kuralı: iş gereksinimlerine uygunluk.
örneğin: ehliyet alacağız. sınavları geçmiş mi vs. bankada kredi verirkek uygun mu vs.
*** ancak kredinin adının hangi karakter sayıları aralığında olacağı vs ise validasyon.
Business içerisinde ValidationRules klasörü bunun içerisine FluentValidation klasörü (nuget paketini yüklüyoruz.)
validasyon işlemleri için nugette fluentcalidasyon paketini kullanacağız.
*** bu validasyonların kötü kodu data annotations ile entity classı içerisinde tanımlıyorlar.
ancak burada hata ileride proporty'nin durumu değişirse sıçtık.
ValidationRules içerisinde ProductValidator diye bir class oluşturduk. 
ProductValidator classına AbstractValidator'ı inherite ediyoruz.
AbstractValidator fluentvalidation paketinden geliyor. içersine generic olarak hangi entity için se onu yazıyor.
ProductValidator : AbstractValidator<Product>
daha sonra içerisinde constructor oluşturup validasyon kurallarımızı buraya yazacağız.
validasyon kurallarımız:
RuleFor(p=>p.ProductName).NotEmpty(); => productname boş olamaz.
RuleFor(p => p.ProductName).MinimumLength(2); ==> productname'in length'i iki karakter olmalıdır.
bu kurallara koşullarda eklenebilir.
örneğin:
RuleFor(p=>p.UnitPrice).NotEmpty(); => unit price boş olamaz.
RuleFor(p=>p.UnitPrice).GreaterThan(0); => unit price 0 dan büyük olmalı.
RuleFor(p=>p.UnitPrice).GreaterThan(10).when(p=>p.CategoryId == 1); => ürünün kategory id si 1 ise o zaman fiyatı 10 dan büyük olmalı.
*** fluentvalidation içerisinde ki kuralların dışında bir şey tanımlamak istersek.
RuleFor(p=>p.ProductName).Must(kuralmetodununadı);
daha sonra kuralmetoduadında bir method create ediyoruz. bool type dönen.
kuralımızı bu metodun içerisine yazıyoruz.
*** yukarıdaki validasyon kuralları ihlal edildiğin dönecek mesajı istersek .WithMessage("hata mesajı");
diye ekleyebiliriz.

Bu kuralları kullanmak için Manager Classlar içerisinde hangi metodda kullanacaksak onun içerisinde

var context = new ValidationContext<Product>(product); ==> Validation contex oluşturuyoruz generic.
ProductValidator productValidator = new ProductValidator(); ==> productValidator ı oluşturduk.
var result = productValidator.Validate(context); ==> productValidator'ın contex için döndüğü değeri result değişkenine atadık.
if(!result.IsValid) ==> result valid değilse
{
	throw new ValidationException(result.Errors) ==> validation exception hata fırlat demek.
}

bu kodu yazdığımız zaman validatorımız ilgili metod için çalışacak.
***Ancak yukarıdaki kodu her metoda yazmak yerine bir tool haline getirebiliriz. yukarıdaki kodda değişen alanlar
Product class, product entity bunlar değişiyor bir tek.
Validasyon kurallarını bütün katmanlar için kullanmamız söz konusu olduğu ilgili kodu Core katmanına taşımamız lazım.
Bunun için:
Core katmanında CrossCuttingConcerns diye bir klasör ekliyoruz.
CrossCuttingConcerns konusunu araştır. Uygulama katmanlarını dikine kesen alanlar.
CrossCuttingConcerns içerisinde Validation klasörü oluşturuyoruz.

var context = new ValidationContext<Product>(product); ==> Validation contex oluşturuyoruz generic.
ProductValidator productValidator = new ProductValidator(); ==> productValidator ı oluşturduk.
var result = productValidator.Validate(context); ==> productValidator'ın contex için döndüğü değeri result değişkenine atadık.
if(!result.IsValid) ==> result valid değilse
{
	throw new ValidationException(result.Errors) ==> validation exception hata fırlat demek.
}
şimdi bu kodu burada öyle bir yazıcazki kullanmak istediğimizde.
ValidationTool.Validate(new ProductValidator(),product);
==> yani içerisinde validator vereyim, birde entity vereyim.
bunun için:
CrossCuttingConcers/Validaton içerisinde ValidationTool isminde bir class oluşturuyoruz.
Bu tür classlar static olarak tanımlanır. sebebi bir kere instance oluşturulur uygulama belleği o instanceı kullanır.
daha sonra bu class içerisinde Validate işlemini yapacak bir method tanımlıyoruz.
*** static bir classın metodlarında static olmalıdır C# da. (javada böyle bir zorunluluk yok.)
Validate metodunun alacağı değişkenler arasında IValidator var. bu AbstractValidator sınıfına inherite olan interfacelerden geliyor.
F12 ile arayıp bulduk.
public static Validate(IValidator validator, object entity) ==> object entity dememizin nedeni dto, entity ler aslında object.
{
	var context = new ValidationContext<object>(entity); ==> Validation contex oluşturuyoruz generic.
	//ProductValidator productValidator = new ProductValidator(); ==> productValidator ı oluşturduk.
	buna ihtiyacımı kalmadı.
	var result = validator.Validate(context); ==> productValidator'ın contex için döndüğü değeri result değişkenine atadık.
	if(!result.IsValid) ==> result valid değilse
	{
		throw new ValidationException(result.Errors) ==> validation exception hata fırlat demek.
	}
}
bu yukarıdaki hali ile değişen kısımları halletik.
Şimdi ManagerClasslarımızda hangi metodda kullanacaksak onun önüne.
ValidatonTool.Validate(new ProductValidator, product);
yazarak validator ı mızı çalıştırabiliriz.


şeklinde kurallarımızı tanımlıyoruz.
bu kurallarımızı çağırabilmek için...

Core'da CrossCuttingConcerns klasörü içerisinde Validation klasörü eğer istersek FluentValidation klasörü de ekleyebilriz.
bunun içserisinde ValidationTools isminde bir class oluşturduk.
Bu classın static olması ve içerisine tanımladığımız metodlarında static olması önemli.
public static void Validate(IValidator validator, object entity) metodunun içerisinde
var context = new ValidationContext<object>(entity);
var result = validator.Validate(context);
if (!result.IsValid) => result valid değilse demek.
{
	throw new ValidationException(result.Errors);
}

daha sonra bu validator ı ilgili bussines manager da kullanıyoruz.
ValidationTool.Validate<new CarValidator>(car);
CarValidator Business.ValidationRules klasörü içerisinde yer alan Car için validasyon kurallarının girildiği yer.

***AoP Nedir?***
Aspect Oriented Programing:
Örneğin metodlarımızı loglamak istiyoruz. bir metod ya başında ya sonunda yada hata verdiğinde loglanır.
Uygulamanın metodunun başında, sonunda, hata verdiğinde çalışmasını istediğim kodlar varsa.
Bu kodları AoP yönetmiyle güzel güzel dizayn edebilirsin.
AoP sayesinde try cath yada manager classlar içerisinde sürekli metod (log) çağırmak zorunda kalmayız.
Bu yönteme Interceptor deniliyor. Kelime anlamı araya girmek. (Metodun başı, metodun sonu, metod hata verdiğinde gibi.)
Bu Interceptors ı oluşturmak için
Core=>Utilities=>Interceptors klasörünü oluşturuyoruz.
Bu Interceptors Klasörü içerisinde:
MethodInterceptionBaseAttribute diye bir class oluştuyoruz.
Attributeları kullanmamızın nedeni loglama,validasyon gibi şeyleri metodların üzerine Attribute olarak koyacağımız için.
[Validate] => gibi validate attribute nu kullan demek.


[AttributeUsage(AttributeTargets.Class | AttributeTargets.Method, AllowMultiple = true, Inherited = true)]
public abstract class MethodInterceptionBaseAttribute : Attribute, IInterceptor
{
	public int Priority { get; set; }  //=> hangi attribute önce çalışsın.

	public virtual void Intercept(IInvocation invocation)
		{

		}
}
AttributeTargets.Class | AttributeTargets.Method => classlara yada methodlara ekleyebilirsin.
AllowMultiple = true => birden fazla kez kullanabilirsin (mesela loglama yapacaksın hem veri tabanına loglasın hemde bir dosyaya)
Inherited = true => inherit edilen bir noktada da bu attribute çalışabilsin.
** bu noktada Core katmanına da Autofac paketinin yüklenmesi gerekiyor.
** ayrıca autofac dynamic proxy paketininde Core katmanına yüklenmesi gerekiyor.
** son olarak aoutofac dependency injection paketini de yüklüyoruz.
*** kısaca tüm autofac paketlerini yüklüyoruz.
Bu paketleri zaten business içerisine yüklemiştik. Oradan alıp Core a yüklemek için solution üzerinden manage nuget packages demek yeterli.
** AoP altyapısını sağlayacak altyapı autofac paketlerinden geliyor.
Paketler yüklendikten sonra:
IInterceptor => using dynamic proxy ile çözüyoruz.
IInvocation => da using dynamic proxy ile.
Bu classtan sonra:

MethodInterception classını oluşturuyoruz. Esas olay burada:
protected virtual void OnBefore(IInvocation invocation) { } //=> öncesinde çalışacak (imza, içi boş override edeceğiz.)
protected virtual void OnAfter(IInvocation invocation) { } //=> sonrasında çalışacak (imza, içi boş override edeceğiz.)
protected virtual void OnException(IInvocation invocation, System.Exception e) { } //=> hata alırsak çalışacak.
protected virtual void OnSuccess(IInvocation invocation) { } //=> metod başarılı olursa çalışacak.
public override void Intercept(IInvocation invocation) //=> bu kısım bizim hangi metodda kulanacağımız. (invocation metod demek.)
        {
            var isSuccess = true;
            OnBefore(invocation); //=> metoddan önce çalışssın
            try
            {
                invocation.Proceed();
            }
            catch (Exception e)
            {
                isSuccess = false;
                OnException(invocation, e); //=> metod çalışırken hata olursa çalışsın.
                throw;
            }
            finally
            {
                if (isSuccess)
                {
                    OnSuccess(invocation); //=> metod başarılı bir şekilde çalışırsa çalışsın.
                }
            }
            OnAfter(invocation); //=> metod çalıştıktan sonra çalışsın.
        }
*** en çok OnBefore ve OnException'ı kullanacağız.(metoddan önce, hata olunca.)
yukarıda class sayesinde buradaki try catchler uygulamak istediğimiz metodda çalışacak.
bu sayede manager classlar içerisinde try cathler havada uçuşmayacak. :)
** attribute eklediğimiz metodlar çalışmadan önce buradaki kurallardan geçecek.

AspectInterceptorSelector classı:

public class AspectInterceptorSelector : IInterceptorSelector
    {
        public IInterceptor[] SelectInterceptors(Type type, MethodInfo method, IInterceptor[] interceptors)
        {
            var classAttributes = type.GetCustomAttributes<MethodInterceptionBaseAttribute> //=> git classın attributelarını oku.
                (true).ToList();
            var methodAttributes = type.GetMethod(method.Name) //=> git metodun attributelarını oku.
                .GetCustomAttributes<MethodInterceptionBaseAttribute>(true);
            classAttributes.AddRange(methodAttributes);

            return classAttributes.OrderBy(x => x.Priority).ToArray(); //=> atributeların çalışma sırasını önceliğe göre belirle.
        }
    }
** using sytem reflection diyerek hata veren yerleri çözüyoruz.

daha sonra Core katmanında Aspects klasörü onun içerisinde Autofac klasörü oluşturuyoruz.
bu klasörde Validation, Loglama, Cachleme gibi işlemler yer alıyor.
Bu nedenle Autofac klasörünün içerisinede Validation klasörü oluşturuyoruz.
Bu klasör içerisinde ValidationAspect classını oluşturuyoruz.

public class ValidationAspect : MethodInterception
    {
        private Type _validatorType;
        public ValidationAspect(Type validatorType) //=> attribute da Type ile vermemiz gerekiyor.
        {
            if (!typeof(IValidator).IsAssignableFrom(validatorType)) //=> gönderilen validatorType bir IValidator değilse hata ver.
            {
                throw new System.Exception("Bu bir doğrulama sınıfı değil!"); //=> hata olarak ne dönsün?
            }

            _validatorType = validatorType;
        }
        protected override void OnBefore(IInvocation invocation) //=> metod öncesi çalışacak 
        {
            var validator = (IValidator)Activator.CreateInstance(_validatorType); //=> reflection
            //=> Activator.CreateInstance => verdiğimiz validator ın çalışma anında bir instancesını oluştur.
            var entityType = _validatorType.BaseType.GetGenericArguments()[0];
            //=> _validatorType 'in base typeını bul. onunda Generic Argümanlarından ilkini al.
            //=> ProductValidator => base type ı AbstractValidator<Product> => bununda generic argümanlarının ilki Product classı
            var entities = invocation.Arguments.Where(t => t.GetType() == entityType);
            //=> product classının parametlerini bul
            foreach (var entity in entities) //=> parametrelerin her birini tek tek gez
            {
                ValidationTool.Validate(validator, entity); //=> ValidationTool'u kullanarak validate et.
            }
        }
    }

Bu classımızı da yaptıktan sonra.
Manager classa gel. Add metodunun üstüne.
[ValidationAspect(typeof(ProductValidator))]
=> Validation aspect i attribute olarak çağır. içerisine ValidatorType ver
Bu sayede add metodu çalışmadan önce (OnBefore kullanıyoruz. Validation Aspect içerisinde override ettik.)
ValidationTool çalışarak metodu validate edecek.

Bu sistemi kurmamıza rağmen bir şey eksik. oda bu validation sistemini kullanması gerektiğini belirtmemiz lazım bir yerde.
Bu yer bussines içersinde DependecnyResolvers/Autofac içerisinde AutofacBusinessModule classı.
Bu class eskiden IPruductService , IProducDal gibi yapılarımızı register ediyordu.
Bunlar istendiğinde karşılık olarak hangi classları vereceğini belirtiyorduk.
şimdi buraya bir yapı daha ekeleyeceğiz.
var assembly ile başlayan yapı.
 public class AutofacBusinessModule : Module
    {
        protected override void Load(ContainerBuilder builder)
        {
            // birisi senden IProductService isterse ProductManager register et demek.
            // singleinstance tek bir instance oluşturuyor. (data tutmayan yerlerde kullanıyoruz).
            builder.RegisterType<ProductManager>().As<IProductService>().SingleInstance();
            // birisi IProductDal isterse EfProductDal ver.
            // burada ProductManager newlenirken bir IProductDal istiyor. (consoledan hatırla).
            builder.RegisterType<EfProductDal>().As<IProductDal>().SingleInstance();

            var assembly = System.Reflection.Assembly.GetExecutingAssembly(); //=> çalışan uygulama içerisinde

            builder.RegisterAssemblyTypes(assembly).AsImplementedInterfaces() //=> implemente edilmiş interfaceleri bul.
                .EnableInterfaceInterceptors(new ProxyGenerationOptions()
                {
                    Selector = new AspectInterceptorSelector() //=> bulduğun interfaceler için AspectInterceptorSelector 'ı çağır.
                    //AspectInterceptorSelector Core katmanında Utilities/Interceptors içerisinde.
                }).SingleInstance();
        }
    }
** kısacası bu yapı register ettiğimiz bütün classlar ve interfaceleri için verilmiş bir aspect var mı [] ile metodun üstüne yazdığımız şey
aspect. aspect varsa AspectInterceptorSelector ı çalıştırıyor.


ancak bu şekilde kullanımlar yapmak yerine AoP teknikleri ile bunu daha iyi hale getirebiliriz.
Bunun için github repodan kod almamız gerekiyor.
Aldığımız kodları koyacağımız yerler.
Core içerisinde, Utilities klasöründe Inteceptors klasörü oluşturuyoruz.
Daha sonra içerisinde 
AspectInterceptorSelector isimli class
MethodInterception isimli class
MethodInterceptionBaseAttribute isimli class


13 üncü Ders:
iş katmanının içerisine iş kodları yazılır. 
iş kuralları ile validasyon kuralları arasındaki farklara dikkat edelim.
Validasyon genellikle veri tabanında da konulan kurallar. 
Validasyon nesnemizin yapısal olarak uygun olup olmadığı.

*** Cross Cutting Concerns ***
Validation
Log
Cache
Transaction
Auth (yetkilendirme)
=> bunları AoP yapıları ile yapıyoruz.

AoP Demo:
Business içerisinde CSS klasörü onun içerisinde de ILogger interface i.
ILoggler interface içerisinde Log() metodunun imzası
CSS içerisinde FileLogger classı oluşturduk. ILogger ile implemente ettik.
Daha sonra DatabaseLogger classı oluşturduk. ILogger ile implemente ettik.
Bu ILogger ı ProductManager içerisine injection yaptık.
Fakat dependencyresolvers içerisinde de ILogger istenince FileLogger yada DatabaseLogger vermesi gerektiğine
dair kodu eklememiz lazım.
Bunun için:
Business/DependencyResolvers/Autofac/AutofacBusinessModule.cs içerisinde
builder.RegisterType<FileLogger>().As<ILogger>().SingleInstance();
=> birisi senden ILogger isterse FileLogger ver demek.


daha sonra ProductManager içerisinde Add metodunun içerisine
tyr catch blogunu koyuyoruz.
add işlemine ait kodları try içerisine koyuyoruz.

** _logger.Log();
try
{
    _productDal.Add(product);
    return new SuccessResult(Messages.ProductAdded); // bir result dönmesi lazım.
}
catch (Exception exception)
{
    _logger.Log();
}
return new ErrorResult();

bu ekleme işlemi öncesinde Log() metodumuzun çalışması için try catch bloğunun üstüne _logger.Log();
ekliyoruz.

=> try üstüdeki _logger.Log(); ekleme işleminde başarılı olursa
=> catch içerisindeki _logger.Log(); ekleme işleminde başarısız olursa
loglama yapacak.
ayrıca burada başarısız olursa bir ErrorResult dönebiliriz. =>(return new ErrorResult();)

bu şekilde çalışacaktır.
Ancak business kodlar ve Başka CrossCuttingConcerns kullanıyorsak burası çorbaya dönecektir.
Bu nedenle AoP yapılarını kullanıyoruz. Hem daha temiz kod yazmak, hem de kod okunurluğunu arttırmak için.

Biz bu yukarıdaki loglama işlemini AoP ile nasıl ele alıyoruz.
Core katmanında/Utilites/Interceptors
Interseption=> araya girmek demek. 
metodun başında çalışmak => (OnBefore)
metodun sonunda çalışmak => (OnAfter)
hata alınca çalışmak => (OnException)
metod başarılı olunca çalışmak => (OnSuccess)

bu klasörde MethodInterception classımız var
içerisinde virtula metodlar var.
virtual metodlar onu ezmemizi bekleyen metodlar. (override) ile.

Core Catmanında Aspects/Autofac/Validation/ValidationAspect.cs classında
MethodInterception classını inherite ediyoruz.
Bu nedenle ValidationAspect classı bize madem bir MethodInterception'ım.
Benim ezmemi istediğin bir method var mı diyor.
Bizde OnBefore metodunu IInvcaiton invocation için ez diyoruz.
invocation metodumuzun adı.
örneğimizde (kullandığımız yer) add metodunun üstünde.
OnBefore => metodun başında çalışan.

protected override void OnBefore(IInvocation invocation)
{
    var validator = (IValidator)Activator.CreateInstance(_validatorType);
    var entityType = _validatorType.BaseType.GetGenericArguments()[0];
    var entities = invocation.Arguments.Where(t => t.GetType() == entityType);
    foreach (var entity in entities)
        {
            ValidationTool.Validate(validator, entity);
        }
}

Coreda CrossCuttinConcerns/Validation/ValidaitonTool.cs classımız.
bu class ne yapıyor.
Buna bir <IValidator validator, object entity> veriyoruz.
IValidator => Business/ValidationRules/FluentValidation/ProductValidator.cs
yani ilgili metodun parametlerini validate etmek istediğimiz FluenValidation classı.
yani kurallarımız olduğu class
Object entitiy ise doğrulamak için verilen varlık.
*** IValidator validator => doğrulama kurallarının olduğu class.
*** Object entity => doğrulanacak class

Core katmanında Aspects/Autofac/Validation/ValidationAspect.cs classı.
Bu class aslında inherite alan classlar takip edildiğinde bir attribute olduğu ortaya çıkıyor.
ve bu class constructorında Type validatorType istiyor.
Bu nedenle ProductManager içerisinde Add metodunun üzerine

[ValidationAspect(typeof(ProductValidator))]

ValidationAspect => attribute içerisinde valitadorType alıyor.
Attribute larda typelar typeof(atanaca_type) şeklinde atanıyor.

Ayrıca ValidationAspect içerisindeki constructor da. şöyle bir yapı var.

if (!typeof(IValidator).IsAssignableFrom(validatorType))
{
    throw new System.Exception("Bu bir doğrulama sınıfı değil!");
}

_validatorType = validatorType;

bu yapı defensive coding. bunu yapmasakta attribute çalışacaktır.
ancak attribute'a validatorType typeof() ile verildiğinden. herhangi bir 
type verilmesi yetecektir. VS burada hata vermeyecektir. çalışma anında hata alacağız.
Böyle bir şey olduğunda validatorType vermediğimizi anlamamız ve bize bir hata msj'ı dönmesini sağlamak
için defensive coding yapıyoruz.

if (!typeof(IValidator).IsAssignableFrom(validatorType))
=> bu ifade verdiğin validatortype'ın bir IValidator mı bunu kontrol ediyor.
=> IsAssignableFrom atabnabiliyor mu demek.
Bu kontrol yapıldıktan sonra atanabilir bir validatorType ise
_validatorType = validatorType;
=> validatorType'ımız eşitleniyor.

[ValidationAspect(typeof(ProductValidator))]
=> burada validatorTypeımızı verdik ancak newlenmedi bellekte yok. bunun için 
=> OnBefore içerisinde
protected override void OnBefore(IInvocation invocation)
{
    var validator = (IValidator)Activator.CreateInstance(_validatorType);
    var entityType = _validatorType.BaseType.GetGenericArguments()[0];
    var entities = invocation.Arguments.Where(t => t.GetType() == entityType);
    foreach (var entity in entities)
    {
        ValidationTool.Validate(validator, entity);
    }
}

var validator = (IValidator)Activator.CreateInstance(_validatorType);
=> ifadesi ile gönderidiğimiz validatorType için instance oluşturuyor. (çalışma anında)
=> bu bir reflection kodu. Burada yapmamızın nedeni instace çalışma anında oluşyor.

var entityType = _validatorType.BaseType.GetGenericArguments()[0];
=> validatorType için ProductValidator ı verdik.
=> yukarıdaki kod ProductValidator classına gidiyor.
=> onun BaseType'ına bakıyor. (AbstractValidator<Product>)
=> bu AbstractValidator'ın aldığı GenericArgümanlarından ilk (Product) argümanın tipini alıyor.

var entities = invocation.Arguments.Where(t => t.GetType() == entityType);
=> burada invocation metodumuz. ProductManager da Add metodunun üstünde kullandığımız için
=> Add(Product product) argümanlarını geziyor.
=> GetType ile Product tipini alıyor. 
=> burada metodun argümanları birden fazla tip almış olabilir. bu durumda bütün tipleri alıyor.
=> ve metodun argümanlarından aldığı tipleri bizim ProductValidator'ımızın baseclassının aldığı generic argümandan
birisimi diye bakıyor ve bu tip için validate işlemini yap.


*** CLEAN CODE ****
*** Business Rules ***
Bir kategoride en fazla 10 ürün olabilir (nasıl yazardın?)
public IResult Add(Product product)
{
    // bir categoryde en fazla 10 ürün olabilir.

    var result =_productDal.GetAll(p => p.CategoryId == product.CategoryId).Count;
    if (result >= 10)
    {
        return new ErrorResult(Messages.ProductCountOfCategoryError);
    }
            
    _productDal.Add(product);
    return new SuccessResult(Messages.ProductAdded); // bir result dönmesi lazım.    

}

Bu şekilde yazdık ama hoca yanlış yol dedi. Update ederken de bu kural geçerli.
Bu şekilde yaparska bu kodları Update içine de yazılmalı.
Bunu yaparsak DRY prensipine ayrkırı. (Dont Repeat Yourself)
kendimizi tekrar edersek ileride 10 ürün 15 ürün olarak güncellenirse.
kuralın yer aldığı bütün alanları düzeltmemiz gerekir.
Bu şekilde yazarsak katmanlı mimari ileride bozulacaktır.

bunu engellemek için ProductManager içerisinde en altta private metod oluşturuyoruz.
private IResult CheckIfCategoryCountOfProduct(int categoryId)
{
    var result = _productDal.GetAll(p => p.CategoryId == categoryId).Count;
    if (result >= 10)
        {
            return new ErrorResult(Messages.ProductCountOfCategoryError);
        }

    return new SuccessResult();
}

kullanmak için ise add metodunun içerisinde metodumuzu çağırıcaz.

if (CheckIfCategoryCountOfProduct(product.CategoryId).Success)
{
    _productDal.Add(product);
    return new SuccessResult(Messages.ProductAdded); // bir result dönmesi lazım.   
}

return new ErrorResult(Messages.ProductCountOfCategoryError);

ileride bu yapıyı iş motoru ile daha iyi bir hale getireceğiz.

yeni iş kuralı : aynı isimde ürün eklenemez.

private IResult CheckIfProductNameExists(string productName)
{
    var result = _productDal.GetAll(p => p.ProductName == productName).Any(); //any uyan kayıt var mı demek.
    if (result == true)
    {
        return new ErrorResult(Messages.ProductNameAlreadyExists);
    }

    return new SuccessResult();
}

==> yukarıda any kullanmak yerine count da kullanabiliri. o zaman result>0 olması koşulunu if in içerisine alacağız.
==> iş kurallarını zamanla başka dosyalara taşıyabiliriz. (başka classlara)

iş kurallarımızı belirli bir standarta göre yazdık hepsi IResult döndürüyor.


*** İş Motoru ***
İş motoru yazarak iş kurallarının yönetilmesini daha düzgün hale getirebiliriz.
İş motorunu yazarken poliformizn yapmamız lazım.
Poliformizin neydi buna bakalım.

Core katmanında:
Core/Utilities/Business/BusinessRules.cs classını oluşturduk.
içerisindeki metod static olacak çünkü bir araç ==> burası önemli.

public static IResult Run(params IResult[] logics)
{
    foreach (var logic in logics) => logics iş kuralları, logic te iş kurallarından teki.
    {
        if (!logic.Success) => iş kuralı başarılı dönmezse (logic.Succes == false) ile aynı daha kısa yazımı
        {
            return logic; => kurala uymayanı döndür
        }
    }
    return null; => başarılı olunca bir şey dönmesine gerek yok. yinede return null; diyoruz ki method hata vermesin.
}

(params IResult[] logics) => params verdiğimiz zaman Run() içerisine istediğimiz kadar IResult verebiliyoruz.
BusinessRules.Run((CheckIfCategoryCountOfProduct(product.CategoryId),(CheckIfProductNameExists(product.ProductName))

***** Javada bir metod static ise (newlenmeden kullanmak için, genellikle araç olan metodlar) metodun yer aldığı
***** class da static olmalıdır.
***** C# da classın da static olmasına gerek yoktur. ve class içerisinde static olan metod ve static olmayan metodlar yer alabilir.
***** Böyle bir durumda static olmayan metodun kullanılabilmesi için new lenmesi gerekir.


Bu metodumuzu ProductManager içerisinde çağırmak için:

 IResult result = BusinessRules.Run(CheckIfProductNameExists(product.ProductName),
                CheckIfCategoryCountOfProduct(product.ProductId));
                => kurallarımızı verdik parametre olarak.
if (result!=null) => result içerisi boş değilse, Yukarıda Run() metodunu tanımlarken başarılı ise null dön dedik.
=> eğer dönen null değilse hata var demek. bu nedenle result!=null şartında result döndüyoruz.
=> result IResult olduğundan dolayı aslında ErrorResult dönecek.
{
    return result;
}
            
_productDal.Add(product);
return new SuccessResult(Messages.ProductAdded); // bir result dönmesi lazım.

BusinessRules classının interface'ini de yazabiliriz. ancak bu durum overdesing a girebilir.
=> bu bir araç olduğu için class gözüyle bakmıyoruz. 
=> çıplak class kalmasını burada es geçiyoruz.

Yeni Kural : eğer mevcut kategori sayısı 15'i geçtiyse sisteme yeni ürün eklenemez.

private IResult CheckIfCategoryNumber()
{
    var result = _categoryDal.GetAll().Count;
    if (result>15)
        {
            return new ErrorResult();
        }

    return new SuccessResult();
}

Yukarıdaki kodun çalışabilmesi için ProductManager içerisine ICategoryDal'ı enjekte etmeliyiz. bunun için ise;

IProductDal _productDal;
ICategoryDal _categoryDal;

public ProductManager(IProductDal productDal,ICategoryDal categoryDal)
{
    _productDal = productDal;
    _categoryDal = categoryDal;
}

***** Bu şekilde yaptık ama hatalı. 
***** Bir EntityManager (ProductManager, CategoryManager) kendisi hariç başka bir Dal'ı enjekte edemez.
=> ProductManager ise IProductDal dışında bir Dal'ı enjekte edemez.
***** Bunun nedeni, kategory için 15 adet dışında başka kurallarda eklerse ve bu yazılan kural başka yerlerde de kullanıyorsa
***** gidip her yere injection yapman lazım ama bir yerden sonra patlar.
=> örneğin kategory sayısı 15'i geçince yeni ürün eklenemez ama biz içecek ve deniz ürünlerini bu kurala tabi tutmuyoruz derse
=> ortalık karışacaktır.

***** Bunu düzeltmek için Dal yerine Service'ini enjekte edeceğiz.

IProductDal _productDal; // burada ne inmemory nede entityframework adı geçecek.
ICategoryService _categoryService;

public ProductManager(IProductDal productDal,ICategoryService categoryService)
{
    _productDal = productDal;
    _categoryService = categoryService;
}

ve iş kuralımızı categoryservice kullanarak yazmamız gerekiyor.
CategoryService istediğimiz datayı veriyor bizde o datayı iş kuralımızda kullanıyoruz.
Eğerki kuralı categorymanager içersine yazarsak bu durumda tek başına bir servistir.
Ama burada kategoriservisi kullanan bir ürünün onu nasıl ele aldığıyla alakalıdır.
İş kuralını da ProductManager içerisine şu şekilde yazıyoruz.

private IResult CheckIfCategoryLimitExeceded()
{
    var result = _categoryService.GetAll().Data.Count;
    if (result>15)
    {
        return new ErrorResult(Messages.CategoryLimitExceded);
    }

    return new SuccessResult();
}

şimdi iş kodlarımızda CategoryManager kullanıdığı için:
Business/DependencyResolvers/Autofac/AutofacBusinessModule.cs dosyasında

builder.RegisterType<CategoryManager>().As<ICategoryService>().SingleInstance();
builder.RegisterType<EfCategoryDal>().As<ICategoryDal>().SingleInstance();

diyerek bağımlılıklarını çözüyoruz.
